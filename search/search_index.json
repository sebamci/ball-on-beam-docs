{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"<p>Welcome to the Ball-on-Beam Control Platform Course!</p> <p>This course serves as technical documentation and a structured introduction to a low-cost Ball-on-Beam platform, developed and optimized as part of a bachelor's thesis at Management Center Innsbruck (MCI).</p> <p>The Ball-on-Beam system is a classical control engineering benchmark. It provides an ideal foundation for learning and applying model-based control strategies such as PID control, Lagrangian modeling, and lead compensation in a real-world setup.</p> <p>In this course, you will:</p> <ul> <li>explore the mechanical and electronic design of the platform</li> <li>learn how to integrate sensors (e.g., soft potentiometers) and actuators (e.g., servos)</li> <li>build and adapt Simulink models for system control</li> <li>utilize simulation and real-time interfaces</li> <li>and bring the system to life through calibration and testing</li> </ul> <p>The content is hands-on and application-oriented: step-by-step guides, visual explanations, and example models help you implement everything efficiently.</p> <p>\ud83d\udd27 Ready? Let\u2019s bring classic control engineering to life \u2014 one beam, one ball at a time.</p> VIDEO"},{"location":"A_System_Overview/01_System_Overview/","title":"System Overview","text":""},{"location":"A_System_Overview/01_System_Overview/#system-overview","title":"System Overview","text":"<p>The Ball-on-Beam platform is a classical benchmark system in control engineering, widely used in education and research to demonstrate real-time feedback control principles. This documentation presents a low-cost and modular version of the platform, developed as part of a bachelor's thesis at the Management Center Innsbruck (MCI).</p> <p>The system consists of a beam actuated by a servo motor and a ball whose position is to be stabilized by feedback control. Due to its inherent instability and nonlinear dynamics, it is ideal for teaching model-based control methods, real-time implementation, and system identification.</p> IMG of real system"},{"location":"A_System_Overview/01_System_Overview/#objectives","title":"Objectives","text":"<p>This project aims to:</p> <ul> <li>Improve the mechanical stability and modularity of the platform</li> <li>Enhance sensor precision and reduce electrical noise through ADC upgrades</li> <li>Implement a Simulink-based control framework for real-time operation</li> <li>Provide full documentation for assembly, calibration, and software setup</li> <li>Facilitate hands-on learning of control engineering concepts through practical exercises</li> </ul>"},{"location":"A_System_Overview/01_System_Overview/#key-features","title":"Key Features","text":"<ul> <li>Mechanical Design: Improved support structure, laser-cut modular parts, and optimized ball guidance.</li> <li>Electronics: High-resolution analog signal acquisition, clean wiring concept, and external user interface elements.</li> <li>Software Stack: Model-based control using Simulink and custom S-Functions, with support for real-time execution on Arduino Due.</li> <li>User Interaction: Integrated manual control mode, system status via NeoPixel indicators, and serial debugging support.</li> </ul>"},{"location":"A_System_Overview/01_System_Overview/#educational-value","title":"Educational Value","text":"<p>The platform is specifically designed for students to:</p> <ul> <li>Gain hands-on experience with sensors, actuators, and embedded systems</li> <li>Understand the design and tuning of PID and lead controllers</li> <li>Experiment with physical modeling and linearization in Simulink</li> <li>Perform real-time control tasks and analyze system responses</li> </ul> <p>This overview serves as the foundation for the remaining documentation, which guides you step-by-step through setup, calibration, simulation, and control design.</p>"},{"location":"B_Assembly/","title":"Assembly","text":""},{"location":"B_Assembly/#assembly","title":"Assembly","text":"<p>This section provides a complete guide for assembling the Ball-on-Beam control platform. The mechanical and electrical structure is composed of five main parts:</p> <ol> <li>The Base Plate, which houses the electronic components and user interface</li> <li>The Top Plate, which holds the bearings and defines the beam axis</li> <li>The Beam, which guides the ball and interfaces with the actuator</li> <li>The Final Mechanical Assembly, where all components are integrated into a working system</li> <li>The Wiring, which connects all electronic components for functionality</li> </ol> <p>Each subchapter provides step-by-step instructions along with visual references from the 3D model or real system.</p> Insert image: Complete 3D model of the assembled platform"},{"location":"B_Assembly/01_base_plate/","title":"Equip the Base Plate","text":""},{"location":"B_Assembly/01_base_plate/#equip-the-base-plate","title":"Equip the Base Plate","text":"<p>The base plate serves as the structural and electronic foundation of the Ball-on-Beam platform. It supports the Arduino board, custom shield, sensors, and user interface elements.</p>"},{"location":"B_Assembly/01_base_plate/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Mount the rubber feet</p> <ul> <li>Attach all four rubber feet to the corners of the base plate.</li> <li>Secure the two on the bottom side with the M4 provided cap nuts.</li> <li>Secure the two on the top side with the round 40mm long spacers.</li> <li>Ensure they are securely fastened to provide stability.</li> </ul> <p></p> <p></p>Rubber Foot (3D model) </li> <li> <p>Attach the other 4 spacers</p> <ul> <li>Use the remaining 4 round 40mm long spacers and secure them with the provided M4 Screws.</li> <li>These will later elevate the top plate and provide clearance for the Arduino and the servo.</li> </ul> </li> <li> <p>Install the SoftPot sensor</p> <ul> <li>Pull off the protective film of the double-sided tape from the SoftPot sensor.</li> <li>Align it with the designated area on the base plate.</li> <li>Press it down firmly to ensure good adhesion.</li> <li>Srew down the frame around the SoftPot sensor using 8 of the provided M3 screws and nuts.</li> </ul> <p></p> <p></p>SoftPot Sensor </li> <li> <p>Srew down the Arduino Due and Shield</p> <ul> <li>Place the Arduino Due on the base plate.</li> <li>Use the provided M3 screws to secure the Arduino Due to the base plate.</li> <li>Place the shield on top of the Arduino.</li> </ul> <p></p> <p></p>Arduino Shield (3D model) </li> <li> <p>Equip the base plate with the control interface</p> <ul> <li>Place the 4 NeoPixel modules in the designated cutouts and use the provided screws and spacers to secure them in place.</li> <li>Place the pushbutton in the designated cutout and secure it with the provided screws and spacers.</li> <li>Attach the rotary angle sensor to the base plate using the provided M3 screws and spacers.</li> </ul> </li> </ol> <p>Once all components\u2014including the Arduino, shield, SoftPot sensor, and control interface\u2014are properly installed, the base plate assembly is complete. The result should resemble the setup shown below.</p> <p></p> Base Plate with mounted components (3D model)"},{"location":"B_Assembly/02_top_plate/","title":"Assemble the Top Plate","text":""},{"location":"B_Assembly/02_top_plate/#assemble-the-top-plate","title":"Assemble the Top Plate","text":"<p>The top plate defines the rotational axis of the beam by holding two precision ball bearings. It is mounted above the base using standoffs.</p>"},{"location":"B_Assembly/02_top_plate/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Install the Servo on the Top Plate</p> <ul> <li>Use the provided carriage bolts together with the Plexiglas spacers, and fasten them securely using the M6 nuts.</li> <li>Ensure the Plexiglas spacers are aligned with the servo motor's rotation axis.</li> <li>Insert the servo motor between the spacers and secure it with the retaining bracket and two more M6 nuts.</li> </ul> <p></p> <p></p>Servo motor assembly (3D model) </li> <li> <p>Assemble the Servo Horn</p> <ul> <li>Attach the servo horn to the shaft of the servo motor.  </li> <li>Make sure to align the horn at a 90\u00b0 angle when the servo is in its full up position.</li> <li>Secure the horn using the provided M2.5 screw. Tighten it firmly, but avoid over-tightening to prevent thread damage.</li> </ul> <p></p> <p></p>Servo horn attached to the servo motor (3D model) <ul> <li>Now you can screw together the two rod ends and use the M3 screw and nut with two washers to secure the rod end to the servo horn.</li> </ul> </li> <li> <p>Attach Beam Support Brackets</p> <ul> <li>Insert the beam support brackets into the designated slots on the top plate.</li> <li>Add the spacers and secure them with the provided M4 threaded rods and nuts.</li> </ul> <p> </p>Beam Support Brackets (3D model) </li> </ol> <p>Once all components\u2014the servo motor, servo horn linkage, and beam support brackets\u2014are securely mounted, the top plate assembly is complete. The result should match the configuration shown below.</p> <p></p> Top Plate fully assembled (3D model)"},{"location":"B_Assembly/03_beam/","title":"Preparing the Beam","text":""},{"location":"B_Assembly/03_beam/#preparing-the-beam","title":"Preparing the Beam","text":"<p>The beam serves as the dynamic element of the Ball-on-Beam platform. It holds the SoftPot position sensor and connects the servo motion to the beam\u2019s rotation. The following steps describe the full assembly process.</p>"},{"location":"B_Assembly/03_beam/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Attach the SoftPot Sensor</p> <ul> <li>Place the SoftPot sensor on the dedicated recessed area of the main beam plate.</li> <li>Peel off the protective film from the double-sided adhesive and press the sensor down firmly.</li> <li>Place the mounting frame over the sensor.</li> <li>Secure the frame with 8 M3 screws and locknuts.</li> </ul> <p> </p>SoftPot mounted on beam (3D model) </li> <li> <p>Connect the Servo Linkage</p> <ul> <li>Insert the servo linkage parts into the dedicated side slots on the beam.</li> <li>Place a spacer between the linkage parts to align the hole.</li> <li>Insert the M3 screw through the hole and secure it with a standard nut.</li> <li>Ensure the linkage is firmly fastened.</li> </ul> <p> </p>Servo linkage connection (3D model) </li> <li> <p>Prepare the Opposite Side</p> <ul> <li>Slide the bearing mounting parts into the corresponding slots.</li> <li>Insert the top bracket between the outer sides. </li> <li>Insert two M3 nuts into the dedicated hexagonal recesses on the opposite end of the beam and fasten the top bracket with two M3 screws.</li> </ul> </li> <li> <p>Add Spacers and Countersunk Screws</p> <ul> <li>Insert two M3 threaded sleeves into the bearing mounting parts.</li> <li>Place the spacers underneath the beam structure.</li> <li>Insert two countersunk screws from the bottom and tighten them into the threaded sleeves.</li> <li>Verify alignment of the beam structure and ensure mechanical stiffness.</li> </ul> <p> </p>Beam structure with bearing mount (3D model) </li> </ol> <p>Once all elements\u2014including the SoftPot sensor, servo linkage, and bearing mounts\u2014are securely assembled, the beam is ready for integration. The fully assembled structure should look like the model shown below.</p> <p></p> Fully assembled beam (3D model)"},{"location":"B_Assembly/04_final_assembly/","title":"Final Mechanical Assembly","text":""},{"location":"B_Assembly/04_final_assembly/#final-mechanical-assembly","title":"Final Mechanical Assembly","text":"<p>In this final step, all subassemblies are brought together to complete the Ball-on-Beam platform.</p>"},{"location":"B_Assembly/04_final_assembly/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Mount the Top Plate onto the Base Plate</p> <ul> <li>Carefully align the top plate with the spacers on the base plate.</li> <li>Secure the top plate using 6 M4 screws inserted from above.</li> </ul> </li> <li> <p>Install the Beam</p> <ul> <li>Place the ball bearings into the dedicated bearing recesses on both sides of the top plate\u2019s beam support structure and place the beam in between the brackets of the top plate.</li> <li>Slide the beam axle through the previously inserted bearings.</li> <li>Insert the precision-ground shaft pin through the beam, centering it so that the threaded ends extend equally on both sides.</li> <li>On each side, fasten the shaft using two M6 nuts.</li> <li>Tighten the nuts gently\u2014firm enough to stabilize the beam, but loose enough to allow free rotation over the bearings.</li> </ul> <p> </p>Beam mounted on top plate (3D model) </li> <li> <p>Connect the Servo Rod to the Beam</p> <ul> <li>Attach the rod end of the servo linkage to the designated hole on the beam side.</li> <li>Use a single M3 screw with two washers and a nut to secure the connection.</li> <li>Verify that the linkage moves freely and without mechanical tension.</li> </ul> <p> </p>Servo rod connected to beam (3D model) </li> </ol> <p>Once all components\u2014including the top plate, beam with bearings, and servo linkage\u2014are installed and adjusted, the Ball-on-Beam system is fully assembled and ready for calibration.</p> <p></p> Fully Assembled Ball-on-Beam Platform (3D model)"},{"location":"B_Assembly/05_wiring/","title":"Wiring","text":""},{"location":"B_Assembly/05_wiring/#wiring","title":"Wiring","text":"<p>The wiring of the Ball-on-Beam platform is straightforward. All electronic components are pre-wired or connected directly to the corresponding headers on the custom Arduino shield.</p>"},{"location":"B_Assembly/05_wiring/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Connect all components to the shield</p> <ul> <li>Connect the SoftPot sensor, rotary knob, pushbutton, and NeoPixel modules to their designated ports on the Arduino shield, one cable at a time.</li> <li>Make sure to guide each cable through the corresponding slots in the base plate to maintain a clean and organized layout.</li> <li>All connectors are labeled and polarized to prevent incorrect connections.</li> </ul> </li> <li> <p>Check signal and power connections</p> <ul> <li>Make sure each sensor and interface element is connected to both signal and ground/power as specified.</li> <li>Double-check that the servo motor is connected to the dedicated PWM output.</li> </ul> </li> <li> <p>Cable Management</p> <ul> <li>Use the provided cable ties to neatly secure all wiring to the underside of the base plate.</li> <li>Ensure that no cables interfere with the beam or mechanical movement.</li> <li>Leave enough slack for serviceability, especially near the servo linkage.</li> </ul> </li> </ol> Insert image: Underside of base plate showing cable routing"},{"location":"C_Software/","title":"Software Setup","text":""},{"location":"C_Software/#software-setup","title":"Software Setup","text":"<p>This section provides a step-by-step guide to the software setup required for operating the Ball-on-Beam platform. It covers all essential tools, configuration steps, and calibration procedures needed to get the system running using Simulink and the Arduino-based hardware.</p> <p>The platform is designed for model-based development and real-time control using MATLAB/Simulink in combination with a custom Arduino shield. All control logic is implemented via Simulink blocks and deployed directly to the microcontroller.</p>"},{"location":"C_Software/#structure","title":"Structure","text":"<p>The software setup is divided into the following subchapters:</p> <ul> <li> <p>Required Tools   Installation of MATLAB, Simulink and the necessary toolboxes, such as the Simulink Support Package.</p> </li> <li> <p>Simulink Environment   Loading the custom Simulink block library developed specifically for the Ball-on-Beam platform. This includes sensor input blocks, actuator output blocks, and user interface elements such as the pushbutton, rotary knob, and NeoPixels.</p> </li> <li> <p>Uploading to Arduino   Generating and deploying code using Simulink's Embedded Coder.</p> </li> <li> <p>Calibration   Adjusting sensor and servo parameters for accurate system behavior.</p> </li> <li> <p>Testing and Troubleshooting   Verifying the setup, running initial tests, and diagnosing common issues.</p> </li> </ul>"},{"location":"C_Software/#system-overview-diagram","title":"System Overview Diagram","text":"<p>The figure below shows the overall software architecture of the Ball-on-Beam platform, including key components such as Simulink models, calibration inputs, and real-time I/O.</p> <p></p> System Software Architecture (simplified overview)"},{"location":"C_Software/#required-hardware-interfaces","title":"Required Hardware Interfaces","text":"<p>The following components must be connected before starting the software setup:</p> <ul> <li>Arduino Due + custom shield</li> <li>SoftPot linear sensor</li> <li>Servo motor</li> <li>Rotary knob and pushbutton</li> <li>NeoPixel modules</li> </ul> <p>Ensure that all components are mounted and wired as described in the assembly chapters.</p>"},{"location":"C_Software/01_tools/","title":"Required Tools","text":""},{"location":"C_Software/01_tools/#required-tools","title":"Required Tools","text":"<p>Before setting up the software environment for the Ball-on-Beam platform, make sure all required tools and packages are installed correctly. This section guides you through the installation of MATLAB, Simulink, and the required toolbox.</p>"},{"location":"C_Software/01_tools/#1-matlab-installation","title":"1. MATLAB Installation","text":"<p>The platform requires MATLAB as the base environment for all model-based development and code generation tasks.</p> <ul> <li>Minimum required version: MATLAB R2024a</li> <li>Obtain MATLAB from the official website: \ud83d\udd17 MATLAB Installation Guide</li> </ul> <p>If you're a student, you can use your university license to activate MATLAB.</p>"},{"location":"C_Software/01_tools/#2-simulink-installation","title":"2. Simulink Installation","text":"<p>Simulink must be installed alongside MATLAB. It provides the graphical modeling environment used for system design and simulation.</p> <ul> <li> <p>Make sure to select Simulink during MATLAB installation, or install it later via the Add-On Explorer.</p> </li> <li> <p>Installation Steps:</p> <ol> <li>Open MATLAB.</li> <li>Go to the Home tab and click on Add-Ons &gt; Get Add-Ons.</li> <li>Search for \"Simulink\" and select it.</li> <li>Click on the package and follow the installation instructions.</li> </ol> </li> </ul> <p></p> Installing Simulink through the Add-On Explorer"},{"location":"C_Software/01_tools/#3-toolbox-installation","title":"3. Toolbox Installation","text":"<p>The following toolbox is required to build, simulate, and deploy the model to the Arduino hardware:</p> <p>\ud83d\udd17 Simulink Support Package for Arduino Hardware</p> <ul> <li>Installation Steps:<ol> <li>Open MATLAB.</li> <li>Go to the Home tab and click on Add-Ons &gt; Get Add-Ons.</li> <li>Search for \"Simulink Support Package for Arduino Hardware\".</li> <li>Click on the package and follow the installation instructions.</li> </ol> </li> </ul> <p>All toolboxes can be installed using the Add-On Explorer in MATLAB.</p> <p></p> MATLAB Add-On Explorer"},{"location":"C_Software/01_tools/#4-github-repository","title":"4. GitHub Repository","text":"<p>The custom Simulink block library and all documentation are available in the official GitHub repository:</p> <ul> <li>Github Repository: \ud83d\udd17 sebamci/ball-on-beam-course</li> </ul> <p>You can find the block library under the <code>Simulink/Custom_Library</code> directory. Clone or download the repository to your local machine to access the files.</p> <p>Note: The repository contains only the block library and documentation. The main Simulink model is not included and must be built locally by following the tasks and instructions provided throughout this course.</p>"},{"location":"C_Software/02_simulink_setup/","title":"Simulink Setup","text":""},{"location":"C_Software/02_simulink_setup/#simulink-setup","title":"Simulink Setup","text":"<p>This section explains how to set up the Simulink environment to work with the Ball-on-Beam platform. It includes instructions for loading the custom block library, preparing your workspace, and understanding the main components required to build your own control model.</p>"},{"location":"C_Software/02_simulink_setup/#1-load-the-custom-block-library","title":"1. Load the Custom Block Library","text":"<p>The Ball-on-Beam platform uses a custom Simulink block library that contains pre-configured blocks for sensors, actuators, and control logic.</p> <ul> <li>Open MATLAB.</li> <li>Add the <code>Custom_Library/</code> folder permanently to your MATLAB path by running the following command:</li> </ul> <p></p><pre><code>addpath('path/to/your/ball-on-beam-docs/Simulink/Custom_Library');\nsavepath;\n</code></pre> - Now you can find the custom Ball-on-Beam Library in your Simulink library browser. <p></p> Custom Simulink library containing Ball-on-Beam-specific blocks"},{"location":"C_Software/02_simulink_setup/#2-explore-the-available-blocks","title":"2. Explore the Available Blocks","text":"<p>The library includes blocks for:</p> <ul> <li>Sensor Input (e.g. SoftPot, rotary knob)</li> <li>Actuator Output (e.g. Servo Motor)</li> <li>User Interface (e.g. NeoPixel, Button)</li> </ul> <p>Each block is configured for real-time deployment using Embedded Coder and is compatible with the Arduino Due.</p>"},{"location":"C_Software/02_simulink_setup/#3-configure-hardware-in-simulink","title":"3. Configure Hardware in Simulink","text":"<p>Before generating code or uploading to the Arduino Due, you must configure the Simulink model for the correct hardware platform.</p> <p>Follow these steps to select the Arduino Due as target hardware:</p> <ol> <li>Open a new empty Simulink model.</li> <li>Click on the \"Model Settings\" button (or use <code>Ctrl+E</code>).</li> <li>In the Configuration Parameters window, go to \"Hardware Implementation\".</li> <li>Under \"Hardware board\", select <code>Arduino Due</code> from the dropdown list.</li> <li>Apply all settings and close the window.</li> </ol> <p>This configuration ensures that code generation and deployment are set up correctly for the Arduino Due.</p> <p></p> Access the Model Settings via the toolbar or Ctrl+E <p></p> Model Configuration Parameters window <p></p> Hardware Implementation tab with Arduino Due selected <p>Once the hardware is correctly configured, you can proceed with initial testing and troubleshooting to ensure the system operates as expected before starting with the course tasks.</p>"},{"location":"C_Software/03_testing/","title":"Test & Troubleshooting","text":""},{"location":"C_Software/03_testing/#test-troubleshooting","title":"Test &amp; Troubleshooting","text":"<p>Before starting with the implementation tasks, it's important to verify that your hardware and software setup are working correctly. This section guides you through a basic test to ensure communication between Simulink and the Arduino are functioning properly.</p>"},{"location":"C_Software/03_testing/#1-run-a-minimal-simulink-test","title":"1. Run a Minimal Simulink Test","text":"<ul> <li> <p>Create a simple Simulink model that:</p> <ul> <li>Lights up the onboard LED of the Arduino Due.</li> <li>Therefore use the <code>Digital Output</code> block from the <code>Simulink Support Package for Arduino Hardware</code> library and set the pin to <code>13</code>.</li> <li>Connect the block to a <code>Constant</code> block set to <code>1</code> (to turn on the LED).</li> </ul> </li> <li> <p>Run the model using the <code>Monitor &amp; Tune</code> in the Hardware tab in Simulink.</p> </li> <li> <p>If the onboard LED lights up, your Simulink setup is correctly communicating with the Arduino Due.</p> </li> <li>You can now set the <code>Constant</code> block to <code>0</code> to turn off the LED.</li> </ul> <p></p> Minimal Simulink test model to verify Arduino communication <p></p> Run your model on the Arduino Due"},{"location":"C_Software/03_testing/#2-verify-usb-connection","title":"2. Verify USB Connection","text":"<ul> <li>If the LED does not respond, check the USB connection:<ul> <li>Ensure you are using the programming USB port on the Arduino Due.</li> <li>The board should be recognized by your computer.</li> </ul> </li> <li>Connect the Arduino Due to your computer using the programming USB port.</li> <li>In MATLAB, use the following command to list available serial devices:</li> </ul> <pre><code>serialportlist(\"all\")\n</code></pre> <p>Your Arduino Due should appear as a serial device (e.g. <code>COM4</code> or <code>/dev/ttyACM0</code>).</p>"},{"location":"C_Software/03_testing/#6-common-issues","title":"6. Common Issues","text":"Problem Possible Cause Suggested Fix No response from Arduino Wrong USB port, driver missing Use programming USB and check <code>serialportlist</code> Upload error Board not detected or incorrect model settings Recheck \"Hardware Implementation\" tab <p>If everything works as expected, you're now ready to begin the practical implementation tasks in this course.</p>"},{"location":"D_Course_tasks/","title":"Course Tasks","text":""},{"location":"D_Course_tasks/#course-tasks","title":"Course Tasks","text":"<p>This section provides a structured overview of the course tasks for the Ball-on-Beam project, guiding you step by step through development, calibration, and testing phases.</p>"},{"location":"D_Course_tasks/#structure","title":"Structure","text":"<p>The course is divided into the following tasks:</p> <ol> <li> <p>Read Ball Position    Read analog position data from the beam SoftPot and calibrate it using Simulink.</p> </li> <li> <p>Control the Beam    Control the beam angle using PWM output and calibrate the neutral position.</p> </li> <li> <p>Move the Beam Manually    Use the analog rotary sensor to directly control the servo motor without feedback. This allows intuitive testing and manual balancing of the ball.</p> </li> <li> <p>Generate Setpoints    Implement constant and dynamic target values (e.g. sine, step) to test controller behavior.</p> </li> <li> <p>Add Setpoints with Control SoftPot    Use a second SoftPot sensor to define the dynamic target position (setpoint) of the ball in real-time.</p> </li> <li> <p>Implement Basic PID Control    Test a basic PID controller using your setpoint and beam position data.</p> </li> <li> <p>Tune the PID Controller    Analyze system behavior with tuned PID parameters and optimize for stability and response.</p> </li> <li> <p>Track Ball with SoftPot    Implement a control loop that uses the SoftPot to track the ball position dynamically, adjusting the beam angle accordingly.</p> </li> <li> <p>Add User Interface    Switch between control modes using a pushbutton and indicate system states with NeoPixel LEDs.</p> </li> <li> <p>Show Mode    Integrate all functions into a final demonstration-ready setup combining real-time control and user interface.</p> </li> </ol> <p>Each task builds upon the previous one, make sure to complete them in order and always work in the same Simulink model and expand it as you progress.</p>"},{"location":"D_Course_tasks/#navigation","title":"Navigation","text":"<p>The course tasks are structured to allow easy navigation between different sections. Each task builds upon the previous one, ensuring a smooth and logical progression. Use the navigation menu on the left side of the page to quickly access each chapter.</p>"},{"location":"D_Course_tasks/01_beam_softpot/","title":"I. Read Ball Position","text":""},{"location":"D_Course_tasks/01_beam_softpot/#i-read-ball-position","title":"I. Read Ball Position","text":"<p>This task introduces the SoftPot linear position sensor as the primary input for detecting the ball\u2019s position on the beam. You will learn how to connect it, read its analog values in Simulink, calibrate its range, and visualize the measurement.</p>"},{"location":"D_Course_tasks/01_beam_softpot/#1-connect-and-initialize","title":"1. Connect and Initialize","text":"<ul> <li>The Beam SoftPot sensor is connected to the <code>Beam</code> Molex KK input of the Arduino shield via the provided cable.</li> <li>In Simulink, open your model and drag the <code>Calib_Beam_SoftPot</code> block from the custom library into your diagram.</li> <li>Connect the output of the <code>Calib_Beam_SoftPot</code> block to a <code>Display</code> block to monitor the raw analog values.</li> </ul> <p>Make sure the sensor is properly fixed on the beam and aligned with the ball path.</p> <p></p> Calib_Beam_SoftPot block connected to Display for calibration"},{"location":"D_Course_tasks/01_beam_softpot/#2-calibration","title":"2. Calibration","text":"<ul> <li>Move the ball to the far left of the beam and note the raw ADC value shown in the <code>Display</code>.</li> <li>Then move the ball to the far right and record that value as well.</li> <li>These two values define the sensor's minimum and maximum.</li> <li>Drag the <code>Beam_SoftPot</code> block from the custom library into your model.</li> <li>Double click the <code>Beam_SoftPot</code> block to set and apply these values as calibration parameters.</li> <li>Connect the output of the <code>Beam_SoftPot</code> block to a <code>Scope</code>.</li> </ul> <p>The output of the calibration block is now a normalized position signal in millimeters.</p> <p></p> Calibrated SoftPot block connected to Scope"},{"location":"D_Course_tasks/01_beam_softpot/#3-run-your-first-bob-model","title":"3. Run Your First BoB Model","text":"<p>Now that the SoftPot is calibrated and integrated into your model, it's time to run your first simulation on the hardware.</p> <p>Follow these steps:</p> <ol> <li>Ensure that the Arduino Due is connected via the programming USB port.</li> <li>Verify that the model is correctly configured for hardware deployment (see the previous setup chapters).</li> <li>Click on <code>Monitor &amp; Tune</code> in the Simulink <code>HARDWARE</code> tab.</li> <li>After successful deployment, observe the Scope or Display block output while manually moving the ball across the beam.</li> </ol> <p>This test confirms that Simulink is communicating correctly with the hardware and that the SoftPot is providing meaningful, real-time data.</p> <p></p> Scope of Ball tracked by the SoftPot in real-time"},{"location":"D_Course_tasks/01_beam_softpot/#4-test-and-validate","title":"4. Test and Validate","text":"<ul> <li>Move the ball slowly across the beam and verify that the Scope signal reacts smoothly and proportionally.</li> <li>The full range should approximately match the physical length of the beam (0\u202fmm to 189\u202fmm).</li> <li>Look out for:<ul> <li>Non-linearity</li> </ul> </li> </ul> <p>Note: The discontinuities in the graph occur when the ball reaches the edge of the beam and temporarily loses contact with the SoftPot sensor.</p>"},{"location":"D_Course_tasks/01_beam_softpot/#5-summary","title":"5. Summary","text":"Step Action Hardware Control SoftPot must be connected via RLU 3-pin cable Calibration Use <code>Calib_Beam_SoftPot</code> block from custom library Simulink Block Use <code>Read_Ball_Position</code> block from custom library Visualization Scope block or display block for real-time feedback <p>Once this task is complete, you have a reliable analog input for ball position and can proceed with servo integration in the next task.</p>"},{"location":"D_Course_tasks/02_servo/","title":"II. Control the Beam","text":""},{"location":"D_Course_tasks/02_servo/#ii-control-the-beam","title":"II. Control the Beam","text":"<p>This task introduces the servo motor that adjusts the beam angle. You will learn how to integrate the motor in Simulink, send control signals, and calibrate the the neutral position to ensure precise beam movement.</p>"},{"location":"D_Course_tasks/02_servo/#1-connect-and-initialize","title":"1. Connect and Initialize","text":"<ul> <li>The servo motor is connected to the designated <code>SERVO</code> Molex KK output on the Arduino shield:<ul> <li>Red wire: VCC (R)</li> <li>Black wire: GND (B)</li> <li>White wire: Signal (W)</li> </ul> </li> <li>In Simulink, open your model and drag the <code>ServoPositionController</code> block from the custom library into your diagram.</li> <li>Connect the input of the block to a <code>Constant</code> block (0 for center position) or a <code>Slider Gain</code> block for interactive testing.</li> </ul> <p>Make sure the servo is securely mounted and not mechanically blocked.</p> <p></p> Servo block connected to a constant input"},{"location":"D_Course_tasks/02_servo/#2-calibrate-neutral-position","title":"2. Calibrate Neutral Position","text":"<p>The servo needs to be centered so the beam is in a horizontal position when the input signal is at 0\u202frad.</p> <ul> <li>Use a <code>Constant</code> block with a value of <code>0</code> connected to the <code>ServoPositionController</code> block.</li> <li>Deploy the model using <code>Monitor &amp; Tune</code>.</li> <li>Manually adjust the servo horn and the two rod ends until the beam is perfectly parallel to the top plate.</li> <li>Tighten the servo horn screw carefully after alignment.</li> </ul> <p>\u26a0\ufe0f The input of the <code>ServoPositionController</code> block directly represents the desired beam angle in radians. For example, <code>0</code> corresponds to a level beam, while positive or negative values tilt the beam accordingly. This definition is important for the later implementation of the feedback controller.</p> <p></p> Servo horn mounted at neutral (0\u00b0) beam angle"},{"location":"D_Course_tasks/02_servo/#3-test-range-of-motion","title":"3. Test Range of Motion","text":"<ul> <li>Now adda <code>Knob</code>block to your model and connect it to the <code>Constant</code> to control the servo position dynamically.</li> <li>Set the knob range to <code>[-0.07, 0.07]</code> to cover the full range of motion.</li> <li>Deploy the model and turn the knob to observe the servo movement.</li> </ul> Testing servo response with dynamic input"},{"location":"D_Course_tasks/02_servo/#4-summary","title":"4. Summary","text":"Step Action Hardware Servo connected correctly to shield servo output Simulink Block Use <code>ServoPositionController</code> from custom library Calibration Adjust horn for horizontal beam at 0\u00b0 input Input Signal Start with constant 0\u00b0, then test with dynamic sources Testing Verify full movement range <p>Once the servo responds correctly and the beam moves reliably, you're ready to proceed with manual control using the rotary knob on the Ball on Beam system.</p>"},{"location":"D_Course_tasks/03_rotary_knob/","title":"III. Move the Beam Manually","text":""},{"location":"D_Course_tasks/03_rotary_knob/#iii-move-the-beam-manually","title":"III. Move the Beam Manually","text":"<p>In this task, you will use the rotary knob as an analog input to manually control the beam angle. This setup allows you to interactively test the system and observe how the beam responds to different user inputs without automatic feedback. The difficulty of manually balancing the ball will become apparent \u2014 reinforcing the motivation for feedback control.</p>"},{"location":"D_Course_tasks/03_rotary_knob/#1-connect-and-initialize","title":"1. Connect and Initialize","text":"<ul> <li>The rotary knob (analog potentiometer) is connected to the <code>POTI</code> Grove connector input on the shield.</li> <li>In Simulink, drag the block <code>Rotary_Pot</code> from the custom library into your model.</li> <li>Connect the output of the <code>Rotary_Pot</code> block directly to the input of the <code>Servo_Position_Controller</code> block.</li> </ul> <p>This configuration creates a direct, manual control loop where the servo angle follows the knob position.</p> <p></p> Manual mode: Rotary knob directly drives the servo"},{"location":"D_Course_tasks/03_rotary_knob/#2-understand-the-signal-mapping","title":"2. Understand the Signal Mapping","text":"<ul> <li>The <code>Rotary_Manual</code> block maps the analog input to a beam angle in radians.</li> <li>The mapping range is: <code>0 V</code> \u2192 <code>-0.07 rad</code> (beam tilted left) <code>3.3 V</code> \u2192 <code>+0.07 rad</code> (beam tilted right)</li> </ul>"},{"location":"D_Course_tasks/03_rotary_knob/#3-deploy-and-test","title":"3. Deploy and Test","text":"<ul> <li>Deploy the model using <code>Monitor &amp; Tune</code>.</li> <li>Rotate the knob slowly and observe how the beam reacts in real time.</li> </ul> <p>This test verifies that the full analog input range is usable and that the actuator responds as expected.</p> <p></p> Manual beam control using the rotary input"},{"location":"D_Course_tasks/03_rotary_knob/#4-summary","title":"4. Summary","text":"Step Action Hardware Rotary knob connected to <code>Rotary</code> Molex input Simulink Blocks <code>Rotary_Manual</code> block connected to <code>Servo_Position_Controller</code> Signal Range Manual input mapped to \u00b10.07 rad beam angle Testing Observe real-time control and beam response during knob rotation <p>Once you are confident with the manual control, you can proceed to implement and test automatically generated setpoints.</p>"},{"location":"D_Course_tasks/04_setpoint/","title":"IV. Generate Setpoints","text":""},{"location":"D_Course_tasks/04_setpoint/#iv-generate-setpoints","title":"IV. Generate Setpoints","text":"<p>In this task, you will learn how to generate setpoints for the target position of the ball on the beam. These reference values are essential for later automatic control and allow you to simulate different motion profiles. You will also manually try to follow the setpoints using the rotary knob from the previous task.</p>"},{"location":"D_Course_tasks/04_setpoint/#1-add-setpoint-block","title":"1. Add Setpoint Block","text":"<ul> <li>In Simulink there are different ways to generate setpoints:</li> <li><code>Constant</code> setpoint (e.g. 100\u202fmm)</li> <li><code>Step</code> change (e.g. from 50\u202fmm to 150\u202fmm)</li> <li><code>Repeating Sequence Stair</code> for periodic motion</li> </ul> <p>These setpoints represent the desired ball position in millimeters.</p> <p></p> Different blocks that can be used as Setpoints"},{"location":"D_Course_tasks/04_setpoint/#2-visualize-the-setpoint","title":"2. Visualize the Setpoint","text":"<ul> <li>Connect the output of the <code>Setpoint_Generator</code> block to the same <code>Scope</code> as the <code>Read_Ball_Position</code> Block.</li> <li>Run the model using <code>Monitor &amp; Tune</code>.</li> <li>Verify that the generated setpoint signal behaves as expected (e.g. changes smoothly or switches at a defined time).</li> </ul> Example setpoint signal displayed in Scope"},{"location":"D_Course_tasks/04_setpoint/#3-try-to-follow-the-setpoint-manually","title":"3. Try to Follow the Setpoint Manually","text":"<ul> <li>Display the ball position (from <code>Read_Ball_Position</code>) and the setpoint on the same Scope.</li> <li>Try to move the knob in a way that makes the ball position track the setpoint.</li> <li>You can start with something simple like a constant setpoint or a step change, and then try more complex waveforms.</li> </ul> <p>This task demonstrates how difficult it is to manually follow even a simple trajectory. It provides an intuitive motivation for the next step: automatic PID control.</p> <p></p> Manual attempt to follow a generated setpoint"},{"location":"D_Course_tasks/04_setpoint/#4-summary","title":"4. Summary","text":"Step Action Block Use <code>Setpoint_Generator</code> from custom library Output Signal Target ball position in millimeters Use Case Combine with manual control and compare real vs. desired position Goal Understand the need for closed-loop feedback <p>Next, you will integrate the second SoftPot to dynamically control the setpoint during operation.</p>"},{"location":"D_Course_tasks/05_control_softpot/","title":"V. Adjust Target with SoftPot","text":""},{"location":"D_Course_tasks/05_control_softpot/#adjust-target-with-softpot","title":"Adjust Target with SoftPot","text":"<p>In this task, you will replace the fixed setpoint from Simulink with a second SoftPot sensor. This Control SoftPot allows the user to define the desired ball position interactively by physically sliding a ball along the sensor. The setpoint becomes dynamic and analog \u2013 ideal for testing real-time system behavior.</p>"},{"location":"D_Course_tasks/05_control_softpot/#1-extend-the-model","title":"1. Extend the Model","text":"<p>Continue working with your existing model. Replace the Simulin setpoint block used with the <code>Control_SoftPot</code> block from the custom library:</p> <ul> <li>The <code>Control_SoftPot</code> block reads the analog signal from the dedicated SoftPot and it can be used as a setpoint source.</li> <li>Its output is the desired ball position in millimeters (same format as the previous setpoints).</li> <li>Connect the output to the Scope, that was previously used to visualize the setpoint and ball position.</li> </ul> <p>This change makes your system respond to real-time user input from the physical slider.</p> <p></p> Control SoftPot replacing the previous setpoint generator"},{"location":"D_Course_tasks/05_control_softpot/#2-connect-and-initialize","title":"2. Connect and Initialize","text":"<ul> <li>The Control SoftPot is connected to the <code>Control</code> Molex KK input on the Arduino shield.</li> <li>In Simulink, double-click the <code>Control_SoftPot</code> block to enter the calibrated ADC min/max values.</li> <li>These values can be measured similarly to the Beam SoftPot in the first task (move the ball to both ends and note the ADC values in Scope using the <code>Calib_Control_SoftPot</code>).</li> </ul> <p>Hint: You can use a new Simulink model with just the <code>Calib_Control_SoftPot</code> block to easily measure these values.</p> <p></p> Calibration of Control SoftPot via Scope"},{"location":"D_Course_tasks/05_control_softpot/#3-live-testing","title":"3. Live Testing","text":"<ul> <li>Deploy the updated model using <code>Monitor &amp; Tune</code>.</li> <li>Move the ball along the Control SoftPot.</li> <li>Observe the resulting setpoint change in real time in the Scope.</li> <li>You should now be able to manually command a new desired ball position at any time.</li> </ul> <p>This setup simulates user interaction in a real control system and prepares the architecture for PID integration.</p>"},{"location":"D_Course_tasks/05_control_softpot/#4-try-to-follow-the-new-setpoint-with-the-rotary-knob","title":"4. Try to Follow the new Setpoint with the Rotary Knob","text":"<ul> <li>Use the rotary knob as before, but now the setpoint is dynamic.</li> <li>If the ball on the control Softpot is moving it is almost impossible to follow the setpoint manually with the rotary knob.</li> </ul> <p>This illustrates again the challenge of manual control and motivates the need for automatic feedback control.</p>"},{"location":"D_Course_tasks/05_control_softpot/#5-summary","title":"5. Summary","text":"Step Action Hardware Control SoftPot connected to <code>Control</code> Molex input Initialize Use <code>Calib_ Control_SoftPot</code> from custom library to get min-/max-values Simulink Block Use <code>Control_SoftPot</code> block from custom library Output Signal Dynamic setpoint (ball position in mm) Test Goal Observe setpoint change in Scope while moving the ball <p>Once you're confident with real-time setpoint adjustment, you're ready to implement the automatic PID controller.</p>"},{"location":"D_Course_tasks/06_pid_basic/","title":"VI. Basic PID Controller","text":""},{"location":"D_Course_tasks/06_pid_basic/#vi-basic-pid-control","title":"VI. Basic PID Control","text":"<p>In this task, you will add a PID controller to your model. The controller automatically adjusts the beam angle to minimize the difference between the desired setpoint (e.g. from the Control SoftPot) and the actual ball position (from the Beam SoftPot).</p>"},{"location":"D_Course_tasks/06_pid_basic/#1-add-the-pid-controller-block","title":"1. Add the PID Controller Block","text":"<p>Continue working in your existing model and add the following components:</p> <ul> <li>Drag the <code>PID Controller</code> block from the Simulink library into your model.</li> <li>Connect the setpoint signal (from <code>Control_SoftPot</code>) to the positive input of a <code>Sum</code> block.</li> <li>Connect the ball position signal (from <code>Read_Ball_Position</code>) to the negative input of the same <code>Sum</code> block.</li> <li>The error signal (setpoint \u2212 position) goes into the <code>PID Controller</code> block.</li> <li>Connect the PID output to the <code>Servo_Position_Controller</code>.</li> <li>Connect the output of the <code>Read_Ball_Position</code> block and your setpoint to a <code>Scope</code> to visualize the actual position.</li> </ul> <p>You now have a full closed-loop control system for automatic ball balancing.</p> <p></p> Closed-loop control with PID controller"},{"location":"D_Course_tasks/06_pid_basic/#2-initial-pid-parameters","title":"2. Initial PID Parameters","text":"<p>Use the following starting values for the PID controller:</p> Parameter Value P 0.0004 I 0.00045 D 0.00007 N 10.00 <ul> <li>Double-click the <code>PID Controller</code> block to enter these values.</li> <li>These parameters are suitable for initial testing and allow you to observe the system response.</li> </ul>"},{"location":"D_Course_tasks/06_pid_basic/#3-deploy-and-observe","title":"3. Deploy and Observe","text":"<ul> <li>Run the model using <code>Monitor &amp; Tune</code>.</li> <li>Use different setpoints to observe how the system reacts to setpoint changes.</li> <li>The PID controller adjusts the beam angle to bring the actual ball to the desired position.</li> </ul> <p>Watch out for overshooting, oscillations, or slow convergence \u2013 all of these can be improved later during fine-tuning.</p> <p></p> Real-time tracking of setpoint and actual ball position with basic PID"},{"location":"D_Course_tasks/06_pid_basic/#4-summary","title":"4. Summary","text":"Step Action Controller Use <code>PID Controller</code> from Simulink library Input Error signal: setpoint \u2013 ball position Output Beam angle command (radians) to <code>Servo_Position_Controller</code> Goal Stabilize the ball at a moving setpoint <p>With this setup, you\u2019ve built your first functional feedback control loop! In the next task, you will improve the controller performance through systematic PID tuning.</p>"},{"location":"D_Course_tasks/07_pid_expert/","title":"VII. Tune the PID Controller","text":""},{"location":"D_Course_tasks/07_pid_expert/#vii-tune-the-pid-controller","title":"VII. Tune the PID Controller","text":"<p>This task focuses on improving the performance of your PID controller by adjusting the individual parameters for proportional (P), integral (I), and derivative (D) action. Fine-tuning is essential for achieving fast, stable, and precise ball control.</p>"},{"location":"D_Course_tasks/07_pid_expert/#1-observe-the-current-behavior","title":"1. Observe the Current Behavior","text":"<p>Before making any changes, carefully analyze how your system responds with the initial parameters:</p> <ul> <li>Is the response too slow or too aggressive?</li> <li>Does the ball overshoot the target position?</li> <li>Are there oscillations or noise in the output?</li> </ul> <p>Use the Scope to display both the setpoint and the actual ball position for direct comparison.</p>"},{"location":"D_Course_tasks/07_pid_expert/#2-adjust-pid-parameters","title":"2. Adjust PID Parameters","text":"<p>Tune each parameter one at a time while keeping the others constant:</p> Parameter Effect P Increases responsiveness; too high may cause oscillations I Eliminates steady-state error; too high can cause slow oscillation D Dampens fast changes; reduces overshoot, but sensitive to noise N Filter for derivative action; helps reduce noise in the derivative term (higher N, less filtering) <p>Start with only proportional gain and set I and D to zero:</p> <ul> <li>Try values like <code>P = 0.05</code>, <code>I = 0</code>, <code>D = 0</code></li> <li>Gradually increase <code>I</code> to reduce offset</li> <li>Carefully add <code>D</code> if you observe overshoot or instability</li> <li>Use <code>N</code> to filter the derivative term if necessary</li> </ul>"},{"location":"D_Course_tasks/07_pid_expert/#3-use-live-tuning","title":"3. Use Live Tuning","text":"<ul> <li>You can also tune your <code>PID Controller</code> while the model is running. Just double-click the block and adjust the parameters in real-time.</li> </ul> <p>Live tuning avoids repeated downloads and accelerates controller design.</p>"},{"location":"D_Course_tasks/07_pid_expert/#4-evaluate-performance","title":"4. Evaluate Performance","text":"<p>After tuning, test your controller with different setpoint profiles:</p> <ul> <li>Step inputs (sudden changes)</li> <li>Sine waves (periodic following)</li> <li>Manual changes via Control SoftPot</li> </ul> <p>The ideal response is fast, smooth, and without overshoot or steady-state error.</p> <p></p> Setpoint tracking after PID tuning"},{"location":"D_Course_tasks/07_pid_expert/#6-summary","title":"6. Summary","text":"Step Action Tuning Strategy Tune one parameter at a time, observe effect Key Focus Balance responsiveness and stability Tools Use live tuning with model variables (Kp, Ki, Kd) Goal Achieve smooth, fast, and accurate ball control <p>With your tuned PID controller, you're ready to add the user interface and mode switching in the next task.</p>"},{"location":"D_Course_tasks/08_subsystem_control_softpot/","title":"VIII. Track Ball with SoftPot","text":""},{"location":"D_Course_tasks/08_subsystem_control_softpot/#viii-track-ball-with-softpot","title":"VIII. Track Ball with SoftPot","text":"<p>In this task, you will build a dedicated subsystem that uses the Control SoftPot as a dynamic reference input. The goal is to regulate the main ball on the beam to the same position as a second ball placed on the Control SoftPot. This demonstrates real-time multi-sensor feedback using your tuned PID controller.</p>"},{"location":"D_Course_tasks/08_subsystem_control_softpot/#1-objective","title":"1. Objective","text":"<p>You will create a modular subsystem that contains all components required to:</p> <ul> <li>Read the Control SoftPot (reference ball position)</li> <li>Read the Beam SoftPot (actual ball position)</li> <li>Calculate the position error</li> <li>Apply PID control</li> <li>Command the beam angle via the servo</li> </ul> <p>This structure prepares your system for advanced tracking and improves reusability and readability.</p>"},{"location":"D_Course_tasks/08_subsystem_control_softpot/#2-build-the-subsystem","title":"2. Build the Subsystem","text":"<p>Inside your Simulink model:</p> <ol> <li>Create a new Subsystem and name it <code>SoftPot_Tracking</code></li> <li>Insert the following blocks into the subsystem:<ul> <li><code>Control_SoftPot</code> \u2013 reads the setpoint position</li> <li><code>Read_Ball_Position</code> \u2013 reads the actual ball position</li> <li><code>Sum</code> block \u2013 computes error: (setpoint \u2212 position)</li> <li><code>PID_Controller_Tuned</code> \u2013 your tuned PID block</li> <li>Output: connect to <code>Servo_Position_Controller</code></li> </ul> </li> </ol> <p></p> Dedicated subsystem for tracking a second ball using Control SoftPot"},{"location":"D_Course_tasks/08_subsystem_control_softpot/#3-connect-the-subsystem","title":"3. Connect the Subsystem","text":"<ul> <li>Place the new subsystem into your main model</li> <li>Feed the output of <code>SoftPot_Tracking</code> directly into the <code>Servo_Position_Controller</code> block</li> <li>Connect Scopes at the outputs of:<ul> <li><code>Control_SoftPot</code> (setpoint)</li> <li><code>Read_Ball_Position</code> (actual position)</li> <li><code>PID_Controller_Tuned</code> (control signal)</li> </ul> </li> </ul> <p>Make sure the analog values from both SoftPots are correctly calibrated and mapped to millimeters.</p>"},{"location":"D_Course_tasks/08_subsystem_control_softpot/#4-run-and-test","title":"4. Run and Test","text":"<ol> <li>Deploy the model using <code>Monitor &amp; Tune</code></li> <li>Place the main ball on the beam</li> <li>Place the reference ball on the Control SoftPot</li> <li>Observe how the system regulates the main ball to match the second ball's position</li> </ol> <p>Try moving the reference ball and observe how the beam adjusts to follow it.</p> <p></p> Scope of system tracking the reference ball in real time using PID control"},{"location":"D_Course_tasks/08_subsystem_control_softpot/#5-summary","title":"5. Summary","text":"Block/Subsystem Function <code>Control_SoftPot</code> Reads dynamic target position <code>Read_Ball_Position</code> Measures actual ball position <code>PID_Controller_Tuned</code> Computes correction based on position error <code>SoftPot_Tracking</code> Self-contained subsystem for dual-ball tracking <p>With this modular control structure, you\u2019ve created a reusable component for real-time reference tracking. This forms the basis for later integration into a complete system.</p>"},{"location":"D_Course_tasks/09_control_panel/","title":"IX. Add User Interface","text":""},{"location":"D_Course_tasks/09_control_panel/#ix-add-user-interface","title":"IX. Add User Interface","text":"<p>In this task, you will integrate the hardware user interface elements into your control system. These include a pushbutton to switch between control modes and NeoPixel LEDs to provide visual feedback. This allows a more intuitive and robust interaction with the Ball-on-Beam system.</p>"},{"location":"D_Course_tasks/09_control_panel/#1-system-overview","title":"1. System Overview","text":"<p>The user interface enables switching between different operating modes of the Ball-on-Beam system:</p> <ul> <li>Simulink Mode \u2013 The setpoint and control loop is modeled in Simulink.</li> <li>Rotary Knob Mode \u2013 The user directly controls the beam angle manually, the setpoint is still defined in Simulink.</li> <li>Control SoftPot Mode \u2013 The user defines the setpoint by placing a second ball on the Control SoftPot sensor. The system then drives the beam to bring the main ball to that target.</li> </ul> <p>Each mode is automatically selected via the pushbutton logic and displayed via NeoPixel LEDs.</p>"},{"location":"D_Course_tasks/09_control_panel/#2-add-ui-blocks-to-the-model","title":"2. Add UI Blocks to the Model","text":"<p>Extend your current Simulink model:</p> <ul> <li>Drag the following blocks from the custom library:<ul> <li><code>PushButton_ModeSelector</code></li> <li><code>NeoPixel_Controller</code></li> </ul> </li> <li>Route the active mode signal to both:<ul> <li>A <code>Switch Case</code> block that selects between manual and automatic control signals</li> <li>The <code>NeoPixel_Controller</code> block for visual feedback</li> </ul> </li> </ul> <p></p> Mode control logic integrated into the control system"},{"location":"D_Course_tasks/09_control_panel/#3-connect-the-hardware","title":"3. Connect the Hardware","text":"<ul> <li>The pushbutton is connected to the <code>MODE</code> Grove connector input on the shield.</li> <li>The NeoPixel chain is connected to the <code>LED</code> JST-SH 3-pin digital output.</li> </ul> <p>Each press advances to the next mode (e.g. Simulink \u2192 Manual \u2192 Softpot \u2192 Simulink \u2026)</p>"},{"location":"D_Course_tasks/09_control_panel/#4-deploy-and-test","title":"4. Deploy and Test","text":"<ul> <li>Deploy the model using <code>Monitor &amp; Tune</code>.</li> <li>Press the pushbutton to cycle through the modes and observe the LED feedback:<ul> <li>Red: Simulink Mode (PID control)</li> <li>Green: Rotary Knob Mode (manual control)</li> <li>Blue: Control SoftPot Mode (dynamic setpoint)</li> </ul> </li> <li>In addition, the NeoPixel LED should light up in the corresponding area and color of the selected mode.</li> </ul>"},{"location":"D_Course_tasks/09_control_panel/#5-summary","title":"5. Summary","text":"Element Function Pushbutton Cycles through control modes Mode Logic Selects between PID and manual signals NeoPixel LEDs Visual feedback of current mode Output Switching Uses multiplexer to forward active signal <p>With this setup, your system becomes user-friendly and robust. You're now ready to finalize your project and prepare it for demonstration.</p>"},{"location":"D_Course_tasks/10_show_mode/","title":"X. Show Mode","text":""},{"location":"D_Course_tasks/10_show_mode/#x-show-mode","title":"X. Show Mode","text":"<p>In this final task, you will combine all previously developed components into one integrated model. This \"Show Mode\" is designed for demonstration purposes and allows you to showcase all hardware features and control modes of the Ball-on-Beam system.</p>"},{"location":"D_Course_tasks/10_show_mode/#1-integrate-all-together","title":"1. Integrate All Together","text":"<p>Ensure your Simulink model includes all necessary components from previous tasks. This includes:</p> <ul> <li>Beam SoftPot: Reads the current ball position</li> <li>Control SoftPot: Provides real-time target position (setpoint)</li> <li>Servo Controller: Controls beam angle based on the selected mode</li> <li>PID Controller: Performs closed-loop control in automatic mode</li> <li>Rotary Knob: Allows manual beam control in manual mode</li> <li>Pushbutton: Toggles between system modes</li> <li>NeoPixel LEDs: Provide live visual feedback on active mode</li> </ul> <p>All subsystems should now work seamlessly together. Mode switching, signal routing, and feedback must be reliable and robust.</p>"},{"location":"D_Course_tasks/10_show_mode/#2-final-model-architecture","title":"2. Final Model Architecture","text":"<p>The final Simulink model includes:</p> <ul> <li>A mode selector logic that determines:<ul> <li>Whether the PID controller is active</li> <li>Which signal is used as the setpoint</li> <li>Whether manual beam control is enabled</li> </ul> </li> <li>A <code>Switch Block</code> for switching between control signals</li> <li>Clear signal routing and groupings for readability</li> </ul> <p></p> Overview of the full system architecture in Show Mode"},{"location":"D_Course_tasks/10_show_mode/#3-demonstration-workflow","title":"3. Demonstration Workflow","text":"<p>Follow these steps for a smooth demonstration:</p> <ol> <li>Turn on the system and deploy the model using <code>Monitor &amp; Tune</code>.</li> <li>Observe LED feedback for the currently active mode.</li> <li>Place the ball at a random starting position on the beam.</li> <li>Use the pushbutton to cycle through modes:</li> <li>In Rotary Mode, manually stabilize the ball.</li> <li>In Control SoftPot Mode, place the second ball to define a setpoint.</li> <li>In Simulink Mode, demonstrate tracking of a generated sine wave or step response.</li> <li>Highlight how the system autonomously moves and stabilizes the ball.</li> </ol> <p>Ensure the beam is level and all sensors are securely connected before running the demo.</p>"},{"location":"D_Course_tasks/10_show_mode/#4-summary","title":"4. Summary","text":"Feature Demonstrated Element Sensor Feedback Ball position and setpoint via SoftPot sensors User Interaction Pushbutton for mode switching Visual Feedback NeoPixel LED mode indication Control Performance PID-regulated stabilization and tracking Manual Override Direct beam control with rotary knob <p>You have now completed the full integration of the Ball-on-Beam system. The platform is ready for presentation, testing, and real-world exploration.</p>"}]}